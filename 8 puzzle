import heapq

goal_state = "123456780"

moves = {
    0: [1,3], 1: [0,2,4], 2: [1,5],
    3: [0,4,6], 4: [1,3,5,7], 5: [2,4,8],
    6: [3,7], 7: [4,6,8], 8: [5,7]
}

def manhattan(state):
    dist = 0
    for i, ch in enumerate(state):
        if ch != "0":
            goal_pos = int(ch) - 1
            dist += abs(goal_pos//3 - i//3) + abs(goal_pos%3 - i%3)
    return dist

def solve_puzzle(start):
    pq = [(manhattan(start), start)]
    visited = {start: None}

    while pq:
        _, state = heapq.heappop(pq)

        if state == goal_state:
            return reconstruct_path(visited, state)
        
        zero_pos = state.index("0")
        
        for move in moves[zero_pos]:
            new_state = list(state)
            new_state[zero_pos], new_state[move] = new_state[move], new_state[zero_pos]
            new_state = "".join(new_state)
            
            if new_state not in visited:
                visited[new_state] = state
                heapq.heappush(pq, (manhattan(new_state), new_state))

    return None

def reconstruct_path(parent, state):
    path = []
    while state:
        path.append(state)
        state = parent[state]
    return path[::-1]

def print_board(state):
    for i in range(0,9,3):
        print(state[i], state[i+1], state[i+2])
    print()

start_state = "724506831"  # scrambled input (can change this)

print("Solving puzzle...")
solution = solve_puzzle(start_state)

if solution:
    for step, s in enumerate(solution):
        print(f"Step {step}:")
        print_board(s)
    print("Puzzle Solved! âœ…")
else:
    print("No solution exists!")
