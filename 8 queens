def is_safe(queen_cols, row, col):
    """
    queen_cols: list where queen_cols[r] = c means a queen is placed at (r,c) for r < row
    Check whether placing a queen at (row, col) conflicts with earlier queens.
    """
    for r in range(row):
        c = queen_cols[r]
        # same column
        if c == col:
            return False
        # same diagonal: difference in rows equals difference in columns
        if abs(c - col) == abs(r - row):
            return False
    return True


def solve_n_queens(N):
    solutions = []
    queen_cols = [-1] * N  # queen_cols[row] = column index of queen in that row

    def backtrack(row):
        if row == N:
            # Found a solution: store a copy of queen_cols
            solutions.append(queen_cols.copy())
            return
        for col in range(N):
            if is_safe(queen_cols, row, col):
                queen_cols[row] = col
                backtrack(row + 1)
                queen_cols[row] = -1  # reset (not strictly necessary, but clear)

    backtrack(0)
    return solutions


def print_board(solution):
    """
    solution: list of length N where solution[r] = c
    Prints the board with 'Q' for queen and '.' for empty.
    """
    N = len(solution)
    for r in range(N):
        row_str = ""
        for c in range(N):
            row_str += "Q " if solution[r] == c else ". "
        print(row_str.rstrip())
    print()


if __name__ == "__main__":
    N = 8
    sols = solve_n_queens(N)
    print(f"Found {len(sols)} solutions for {N}-Queens.\n")

    # Print first 4 solutions as boards (or all if you prefer)
    for i, sol in enumerate(sols, start=1):
        print(f"Solution #{i}: columns per row = {sol}")
        print_board(sol)
        # If you want to pause between solutions, remove the comment from next line:
        # input("Press Enter for next solution...")
